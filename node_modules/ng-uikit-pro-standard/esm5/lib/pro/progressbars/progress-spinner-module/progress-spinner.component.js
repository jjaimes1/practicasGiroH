/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, HostBinding, ChangeDetectionStrategy, Input, ElementRef, NgZone, Renderer2, Directive, } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { PLATFORM_ID, Inject } from '@angular/core';
/**
 * A single degree in radians.
 * @type {?}
 */
import * as ɵngcc0 from '@angular/core';
var DEGREE_IN_RADIANS = Math.PI / 180;
/**
 * Duration of the indeterminate animation.
 * @type {?}
 */
var DURATION_INDETERMINATE = 667;
/**
 * Duration of the indeterminate animation.
 * @type {?}
 */
var DURATION_DETERMINATE = 225;
/**
 * Start animation value of the indeterminate animation
 * @type {?}
 */
var startIndeterminate = 3;
/**
 * End animation value of the indeterminate animation
 * @type {?}
 */
var endIndeterminate = 80;
/* Maximum angle for the arc. The angle can't be exactly 360, because the arc becomes hidden. */
/** @type {?} */
var MAX_ANGLE = 359.99 / 100;
/**
 * Directive whose purpose is to add the mat- CSS styling to this selector.
 * \@docs-private
 */
var MdProgressSpinnerCssMatStylerDirective = /** @class */ (function () {
    function MdProgressSpinnerCssMatStylerDirective() {
    }
    MdProgressSpinnerCssMatStylerDirective.propDecorators = {
        true: [{ type: HostBinding, args: ['class.mat-progress-spinner',] }]
    };
MdProgressSpinnerCssMatStylerDirective.ɵfac = function MdProgressSpinnerCssMatStylerDirective_Factory(t) { return new (t || MdProgressSpinnerCssMatStylerDirective)(); };
MdProgressSpinnerCssMatStylerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MdProgressSpinnerCssMatStylerDirective, selectors: [["", "mdbSpinners", ""], ["mat-progress-spinner"]], hostVars: 2, hostBindings: function MdProgressSpinnerCssMatStylerDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mat-progress-spinner", true);
    } } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MdProgressSpinnerCssMatStylerDirective, [{
        type: Directive,
        args: [{
                selector: '[mdbSpinners], mat-progress-spinner'
            }]
    }], function () { return []; }, { true: [{
            type: HostBinding,
            args: ['class.mat-progress-spinner']
        }] }); })();
    return MdProgressSpinnerCssMatStylerDirective;
}());
export { MdProgressSpinnerCssMatStylerDirective };
if (false) {
    /** @type {?} */
    MdProgressSpinnerCssMatStylerDirective.prototype.true;
}
/**
 * <md-progress-spinner> component.
 */
var MdProgressSpinnerComponent = /** @class */ (function () {
    function MdProgressSpinnerComponent(_ngZone, _elementRef, _renderer, platformId) {
        this._ngZone = _ngZone;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        /**
         * The id of the last requested animation.
         */
        this._lastAnimationId = 0;
        this._mode = 'determinate';
        this._color = 'primary';
        this.isBrowser = false;
        this.isBrowser = isPlatformBrowser(platformId);
    }
    Object.defineProperty(MdProgressSpinnerComponent.prototype, "_ariaValueMin", {
        /**
         * Values for aria max and min are only defined as numbers when in a determinate mode.  We do this
         * because voiceover does not report the progress indicator as indeterminate if the aria min
         * and/or max value are number values.
         */
        get: /**
         * Values for aria max and min are only defined as numbers when in a determinate mode.  We do this
         * because voiceover does not report the progress indicator as indeterminate if the aria min
         * and/or max value are number values.
         * @return {?}
         */
        function () {
            return this.mode === 'determinate' ? 0 : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdProgressSpinnerComponent.prototype, "_ariaValueMax", {
        get: /**
         * @return {?}
         */
        function () {
            return this.mode === 'determinate' ? 100 : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdProgressSpinnerComponent.prototype, "interdeterminateInterval", {
        /** @docs-private */
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () {
            return this._interdeterminateInterval;
        },
        /** @docs-private */
        set: /**
         * \@docs-private
         * @param {?} interval
         * @return {?}
         */
        function (interval) {
            clearInterval(this._interdeterminateInterval);
            this._interdeterminateInterval = interval;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clean up any animations that were running.
     */
    /**
     * Clean up any animations that were running.
     * @return {?}
     */
    MdProgressSpinnerComponent.prototype.ngOnDestroy = /**
     * Clean up any animations that were running.
     * @return {?}
     */
    function () {
        this._cleanupIndeterminateAnimation();
    };
    Object.defineProperty(MdProgressSpinnerComponent.prototype, "color", {
        /** The color of the progress-spinner. Can be primary, accent, or warn. */
        get: /**
         * The color of the progress-spinner. Can be primary, accent, or warn.
         * @return {?}
         */
        function () {
            return this._color;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._updateColor(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdProgressSpinnerComponent.prototype, "value", {
        /** Value of the progress circle. It is bound to the host as the attribute aria-valuenow. */
        get: /**
         * Value of the progress circle. It is bound to the host as the attribute aria-valuenow.
         * @return {?}
         */
        function () {
            if (this.mode === 'determinate') {
                return this._value;
            }
            return;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v != null && this.mode === 'determinate') {
                /** @type {?} */
                var newValue = clamp(v);
                this._animateCircle(this.value || 0, newValue);
                this._value = newValue;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdProgressSpinnerComponent.prototype, "mode", {
        /**
         * Mode of the progress circle
         *
         * Input must be one of the values from ProgressMode, defaults to 'determinate'.
         * mode is bound to the host as the attribute host.
         */
        get: /**
         * Mode of the progress circle
         *
         * Input must be one of the values from ProgressMode, defaults to 'determinate'.
         * mode is bound to the host as the attribute host.
         * @return {?}
         */
        function () {
            return this._mode;
        },
        set: /**
         * @param {?} mode
         * @return {?}
         */
        function (mode) {
            if (mode !== this._mode) {
                if (mode === 'indeterminate') {
                    this._startIndeterminateAnimation();
                }
                else {
                    this._cleanupIndeterminateAnimation();
                    this._animateCircle(0, this._value);
                }
                this._mode = mode;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Animates the circle from one percentage value to another.
     *
     * @param animateFrom The percentage of the circle filled starting the animation.
     * @param animateTo The percentage of the circle filled ending the animation.
     * @param ease The easing function to manage the pace of change in the animation.
     * @param duration The length of time to show the animation, in milliseconds.
     * @param rotation The starting angle of the circle fill, with 0° represented at the top center
     *    of the circle.
     */
    /**
     * Animates the circle from one percentage value to another.
     *
     * @private
     * @param {?} animateFrom The percentage of the circle filled starting the animation.
     * @param {?} animateTo The percentage of the circle filled ending the animation.
     * @param {?=} ease The easing function to manage the pace of change in the animation.
     * @param {?=} duration The length of time to show the animation, in milliseconds.
     * @param {?=} rotation The starting angle of the circle fill, with 0° represented at the top center
     *    of the circle.
     * @return {?}
     */
    MdProgressSpinnerComponent.prototype._animateCircle = /**
     * Animates the circle from one percentage value to another.
     *
     * @private
     * @param {?} animateFrom The percentage of the circle filled starting the animation.
     * @param {?} animateTo The percentage of the circle filled ending the animation.
     * @param {?=} ease The easing function to manage the pace of change in the animation.
     * @param {?=} duration The length of time to show the animation, in milliseconds.
     * @param {?=} rotation The starting angle of the circle fill, with 0° represented at the top center
     *    of the circle.
     * @return {?}
     */
    function (animateFrom, animateTo, ease, duration, rotation) {
        var _this = this;
        if (ease === void 0) { ease = linearEase; }
        if (duration === void 0) { duration = DURATION_DETERMINATE; }
        if (rotation === void 0) { rotation = 0; }
        /** @type {?} */
        var id = ++this._lastAnimationId;
        /** @type {?} */
        var startTime = Date.now();
        /** @type {?} */
        var changeInValue = animateTo - animateFrom;
        // No need to animate it if the values are the same
        if (animateTo === animateFrom) {
            this._renderArc(animateTo, rotation);
        }
        else {
            /** @type {?} */
            var animation_1 = (/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var elapsedTime = Math.max(0, Math.min(Date.now() - startTime, duration));
                _this._renderArc(ease(elapsedTime, animateFrom, changeInValue, duration), rotation);
                // Prevent overlapping animations by checking if a new animation has been called for and
                // if the animation has lasted longer than the animation duration.
                if (id === _this._lastAnimationId && elapsedTime < duration) {
                    requestAnimationFrame(animation_1);
                }
            });
            // Run the animation outside of Angular's zone, in order to avoid
            // hitting ZoneJS and change detection on each frame.
            this._ngZone.runOutsideAngular(animation_1);
        }
    };
    /**
     * Starts the indeterminate animation interval, if it is not already running.
     */
    /**
     * Starts the indeterminate animation interval, if it is not already running.
     * @private
     * @return {?}
     */
    MdProgressSpinnerComponent.prototype._startIndeterminateAnimation = /**
     * Starts the indeterminate animation interval, if it is not already running.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var rotationStartPoint = 0;
        /** @type {?} */
        var start = startIndeterminate;
        /** @type {?} */
        var end = endIndeterminate;
        /** @type {?} */
        var duration = DURATION_INDETERMINATE;
        /** @type {?} */
        var animate = (/**
         * @return {?}
         */
        function () {
            _this._animateCircle(start, end, materialEase, duration, rotationStartPoint);
            // Prevent rotation from reaching Number.MAX_SAFE_INTEGER.
            rotationStartPoint = (rotationStartPoint + end) % 100;
            /** @type {?} */
            var temp = start;
            start = -end;
            end = -temp;
        });
        if (this.isBrowser) {
            if (!this.interdeterminateInterval) {
                this._ngZone.runOutsideAngular((/**
                 * @return {?}
                 */
                function () {
                    _this.interdeterminateInterval = setInterval(animate, duration + 50, 0, false);
                    animate();
                }));
            }
        }
    };
    /**
     * Removes interval, ending the animation.
     */
    /**
     * Removes interval, ending the animation.
     * @private
     * @return {?}
     */
    MdProgressSpinnerComponent.prototype._cleanupIndeterminateAnimation = /**
     * Removes interval, ending the animation.
     * @private
     * @return {?}
     */
    function () {
        this.interdeterminateInterval = null;
    };
    /**
     * Renders the arc onto the SVG element. Proxies `getArc` while setting the proper
     * DOM attribute on the `<path>`.
     */
    /**
     * Renders the arc onto the SVG element. Proxies `getArc` while setting the proper
     * DOM attribute on the `<path>`.
     * @private
     * @param {?} currentValue
     * @param {?=} rotation
     * @return {?}
     */
    MdProgressSpinnerComponent.prototype._renderArc = /**
     * Renders the arc onto the SVG element. Proxies `getArc` while setting the proper
     * DOM attribute on the `<path>`.
     * @private
     * @param {?} currentValue
     * @param {?=} rotation
     * @return {?}
     */
    function (currentValue, rotation) {
        if (rotation === void 0) { rotation = 0; }
        // Caches the path reference so it doesn't have to be looked up every time.
        /** @type {?} */
        var path = (this._path = this._path || this._elementRef.nativeElement.querySelector('path'));
        // Ensure that the path was found. This may not be the case if the
        // animation function fires too early.
        if (path) {
            path.setAttribute('d', getSvgArc(currentValue, rotation));
        }
    };
    /**
     * Updates the color of the progress-spinner by adding the new palette class to the element
     * and removing the old one.
     */
    /**
     * Updates the color of the progress-spinner by adding the new palette class to the element
     * and removing the old one.
     * @private
     * @param {?} newColor
     * @return {?}
     */
    MdProgressSpinnerComponent.prototype._updateColor = /**
     * Updates the color of the progress-spinner by adding the new palette class to the element
     * and removing the old one.
     * @private
     * @param {?} newColor
     * @return {?}
     */
    function (newColor) {
        this._setElementColor(this._color, false);
        this._setElementColor(newColor, true);
        this._color = newColor;
    };
    /** Sets the given palette class on the component element. */
    /**
     * Sets the given palette class on the component element.
     * @private
     * @param {?} color
     * @param {?} isAdd
     * @return {?}
     */
    MdProgressSpinnerComponent.prototype._setElementColor = /**
     * Sets the given palette class on the component element.
     * @private
     * @param {?} color
     * @param {?} isAdd
     * @return {?}
     */
    function (color, isAdd) {
        if (color != null && color !== '') {
            if (isAdd) {
                this._renderer.addClass(this._elementRef.nativeElement, "mat-" + color);
            }
        }
    };
    /** @nocollapse */
    MdProgressSpinnerComponent.ctorParameters = function () { return [
        { type: NgZone },
        { type: ElementRef },
        { type: Renderer2 },
        { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    MdProgressSpinnerComponent.propDecorators = {
        platformId: [{ type: Inject, args: [PLATFORM_ID,] }],
        color: [{ type: Input }],
        value: [{ type: Input }, { type: HostBinding, args: ['attr.aria-valuenow',] }],
        mode: [{ type: HostBinding, args: ['attr.mode',] }, { type: Input }]
    };
MdProgressSpinnerComponent.ɵfac = function MdProgressSpinnerComponent_Factory(t) { return new (t || MdProgressSpinnerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID)); };
MdProgressSpinnerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MdProgressSpinnerComponent, selectors: [["mdb-Spinners"], ["mat-progress-spinner"]], hostVars: 2, hostBindings: function MdProgressSpinnerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-valuenow", ctx.value)("mode", ctx.mode);
    } }, inputs: { color: "color", value: "value", mode: "mode" }, decls: 2, vars: 0, consts: [["viewBox", "0 0 100 100", "preserveAspectRatio", "xMidYMid meet"]], template: function MdProgressSpinnerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "svg", 0);
        ɵngcc0.ɵɵelement(1, "path");
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MdProgressSpinnerComponent, [{
        type: Component,
        args: [{
                selector: 'mdb-Spinners, mat-progress-spinner',
                template: "<!--\n  preserveAspectRatio of xMidYMid meet as the center of the viewport is the circle's\n  center. The center of the circle will remain at the center of the md-progress-spinner\n  element containing the SVG.\n-->\n<svg viewBox=\"0 0 100 100\" preserveAspectRatio=\"xMidYMid meet\">\n  <path></path>\n</svg>",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, { color: [{
            type: Input
        }], value: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-valuenow']
        }], mode: [{
            type: HostBinding,
            args: ['attr.mode']
        }, {
            type: Input
        }], platformId: [{
            type: Inject,
            args: [PLATFORM_ID]
        }] }); })();
    return MdProgressSpinnerComponent;
}());
export { MdProgressSpinnerComponent };
if (false) {
    /**
     * The id of the last requested animation.
     * @type {?}
     * @private
     */
    MdProgressSpinnerComponent.prototype._lastAnimationId;
    /**
     * The id of the indeterminate interval.
     * @type {?}
     * @private
     */
    MdProgressSpinnerComponent.prototype._interdeterminateInterval;
    /**
     * The SVG <path> node that is used to draw the circle.
     * @type {?}
     * @private
     */
    MdProgressSpinnerComponent.prototype._path;
    /**
     * @type {?}
     * @private
     */
    MdProgressSpinnerComponent.prototype._mode;
    /**
     * @type {?}
     * @private
     */
    MdProgressSpinnerComponent.prototype._value;
    /**
     * @type {?}
     * @private
     */
    MdProgressSpinnerComponent.prototype._color;
    /** @type {?} */
    MdProgressSpinnerComponent.prototype.isBrowser;
    /** @type {?} */
    MdProgressSpinnerComponent.prototype.platformId;
    /**
     * @type {?}
     * @private
     */
    MdProgressSpinnerComponent.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    MdProgressSpinnerComponent.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    MdProgressSpinnerComponent.prototype._renderer;
}
/**
 * <md-spinner> component.
 *
 * This is a component definition to be used as a convenience reference to create an
 * indeterminate <md-progress-spinner> instance.
 */
var MdSpinnerComponent = /** @class */ (function (_super) {
    tslib_1.__extends(MdSpinnerComponent, _super);
    function MdSpinnerComponent(elementRef, ngZone, renderer) {
        var _this = _super.call(this, ngZone, elementRef, renderer) || this;
        _this.mode = 'indeterminate';
        return _this;
    }
    /**
     * @return {?}
     */
    MdSpinnerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // The `ngOnDestroy` from `MdProgressSpinner` should be called explicitly, because
        // in certain cases Angular won't call it (e.g. when using AoT and in unit tests).
        _super.prototype.ngOnDestroy.call(this);
    };
    /** @nocollapse */
    MdSpinnerComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone },
        { type: Renderer2 }
    ]; };
    MdSpinnerComponent.propDecorators = {
        true: [{ type: HostBinding, args: ['class.mat-spinner',] }]
    };
MdSpinnerComponent.ɵfac = function MdSpinnerComponent_Factory(t) { return new (t || MdSpinnerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
MdSpinnerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MdSpinnerComponent, selectors: [["mdb-spinners"], ["mat-spinner"], ["mdb-progress-spinner"]], hostVars: 2, hostBindings: function MdSpinnerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mat-spinner", true);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 0, consts: [["viewBox", "0 0 100 100", "preserveAspectRatio", "xMidYMid meet"]], template: function MdSpinnerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "svg", 0);
        ɵngcc0.ɵɵelement(1, "path");
        ɵngcc0.ɵɵelementEnd();
    } }, styles: ["[_nghost-%COMP%]{display:block;height:100px;width:100px;overflow:hidden}[_nghost-%COMP%]   svg[_ngcontent-%COMP%]{height:100%;width:100%;-webkit-transform-origin:center;transform-origin:center}[_nghost-%COMP%]   path[_ngcontent-%COMP%]{fill:transparent;stroke-width:10px;transition:stroke .3s cubic-bezier(.35,0,.25,1)}[mode=indeterminate][_nghost-%COMP%]   svg[_ngcontent-%COMP%]{-webkit-animation-duration:5.25s,2.887s;animation-duration:5.25s,2.887s;-webkit-animation-name:mat-progress-spinner-sporadic-rotate,mat-progress-spinner-linear-rotate;animation-name:mat-progress-spinner-sporadic-rotate,mat-progress-spinner-linear-rotate;-webkit-animation-timing-function:cubic-bezier(.35,0,.25,1),linear;animation-timing-function:cubic-bezier(.35,0,.25,1),linear;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;transition:none}@-webkit-keyframes mat-progress-spinner-linear-rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes mat-progress-spinner-linear-rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes mat-progress-spinner-sporadic-rotate{12.5%{-webkit-transform:rotate(135deg);transform:rotate(135deg)}25%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}37.5%{-webkit-transform:rotate(405deg);transform:rotate(405deg)}50%{-webkit-transform:rotate(540deg);transform:rotate(540deg)}62.5%{-webkit-transform:rotate(675deg);transform:rotate(675deg)}75%{-webkit-transform:rotate(810deg);transform:rotate(810deg)}87.5%{-webkit-transform:rotate(945deg);transform:rotate(945deg)}100%{-webkit-transform:rotate(1080deg);transform:rotate(1080deg)}}@keyframes mat-progress-spinner-sporadic-rotate{12.5%{-webkit-transform:rotate(135deg);transform:rotate(135deg)}25%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}37.5%{-webkit-transform:rotate(405deg);transform:rotate(405deg)}50%{-webkit-transform:rotate(540deg);transform:rotate(540deg)}62.5%{-webkit-transform:rotate(675deg);transform:rotate(675deg)}75%{-webkit-transform:rotate(810deg);transform:rotate(810deg)}87.5%{-webkit-transform:rotate(945deg);transform:rotate(945deg)}100%{-webkit-transform:rotate(1080deg);transform:rotate(1080deg)}}"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MdSpinnerComponent, [{
        type: Component,
        args: [{
                selector: 'mdb-spinners, mat-spinner, mdb-progress-spinner',
                template: "<!--\n  preserveAspectRatio of xMidYMid meet as the center of the viewport is the circle's\n  center. The center of the circle will remain at the center of the md-progress-spinner\n  element containing the SVG.\n-->\n<svg viewBox=\"0 0 100 100\" preserveAspectRatio=\"xMidYMid meet\">\n  <path></path>\n</svg>",
                styles: [":host{display:block;height:100px;width:100px;overflow:hidden}:host svg{height:100%;width:100%;-webkit-transform-origin:center;transform-origin:center}:host path{fill:transparent;stroke-width:10px;transition:stroke .3s cubic-bezier(.35,0,.25,1)}:host[mode=indeterminate] svg{-webkit-animation-duration:5.25s,2.887s;animation-duration:5.25s,2.887s;-webkit-animation-name:mat-progress-spinner-sporadic-rotate,mat-progress-spinner-linear-rotate;animation-name:mat-progress-spinner-sporadic-rotate,mat-progress-spinner-linear-rotate;-webkit-animation-timing-function:cubic-bezier(.35,0,.25,1),linear;animation-timing-function:cubic-bezier(.35,0,.25,1),linear;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite;transition:none}@-webkit-keyframes mat-progress-spinner-linear-rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes mat-progress-spinner-linear-rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes mat-progress-spinner-sporadic-rotate{12.5%{-webkit-transform:rotate(135deg);transform:rotate(135deg)}25%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}37.5%{-webkit-transform:rotate(405deg);transform:rotate(405deg)}50%{-webkit-transform:rotate(540deg);transform:rotate(540deg)}62.5%{-webkit-transform:rotate(675deg);transform:rotate(675deg)}75%{-webkit-transform:rotate(810deg);transform:rotate(810deg)}87.5%{-webkit-transform:rotate(945deg);transform:rotate(945deg)}100%{-webkit-transform:rotate(1080deg);transform:rotate(1080deg)}}@keyframes mat-progress-spinner-sporadic-rotate{12.5%{-webkit-transform:rotate(135deg);transform:rotate(135deg)}25%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}37.5%{-webkit-transform:rotate(405deg);transform:rotate(405deg)}50%{-webkit-transform:rotate(540deg);transform:rotate(540deg)}62.5%{-webkit-transform:rotate(675deg);transform:rotate(675deg)}75%{-webkit-transform:rotate(810deg);transform:rotate(810deg)}87.5%{-webkit-transform:rotate(945deg);transform:rotate(945deg)}100%{-webkit-transform:rotate(1080deg);transform:rotate(1080deg)}}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { true: [{
            type: HostBinding,
            args: ['class.mat-spinner']
        }] }); })();
    return MdSpinnerComponent;
}(MdProgressSpinnerComponent));
export { MdSpinnerComponent };
if (false) {
    /** @type {?} */
    MdSpinnerComponent.prototype.true;
}
/**
 * Module functions.
 */
/**
 * Clamps a value to be between 0 and 100.
 * @param {?} v
 * @return {?}
 */
function clamp(v) {
    return Math.max(0, Math.min(100, v));
}
/**
 * Converts Polar coordinates to Cartesian.
 * @param {?} radius
 * @param {?} pathRadius
 * @param {?} angleInDegrees
 * @return {?}
 */
function polarToCartesian(radius, pathRadius, angleInDegrees) {
    /** @type {?} */
    var angleInRadians = (angleInDegrees - 90) * DEGREE_IN_RADIANS;
    return (radius +
        pathRadius * Math.cos(angleInRadians) +
        ',' +
        (radius + pathRadius * Math.sin(angleInRadians)));
}
/**
 * Easing function for linear animation.
 * @param {?} currentTime
 * @param {?} startValue
 * @param {?} changeInValue
 * @param {?} duration
 * @return {?}
 */
function linearEase(currentTime, startValue, changeInValue, duration) {
    return (changeInValue * currentTime) / duration + startValue;
}
/**
 * Easing function to match material design indeterminate animation.
 * @param {?} currentTime
 * @param {?} startValue
 * @param {?} changeInValue
 * @param {?} duration
 * @return {?}
 */
function materialEase(currentTime, startValue, changeInValue, duration) {
    /** @type {?} */
    var time = currentTime / duration;
    /** @type {?} */
    var timeCubed = Math.pow(time, 3);
    /** @type {?} */
    var timeQuad = Math.pow(time, 4);
    /** @type {?} */
    var timeQuint = Math.pow(time, 5);
    return startValue + changeInValue * (6 * timeQuint + -15 * timeQuad + 10 * timeCubed);
}
/**
 * Determines the path value to define the arc.  Converting percentage values to to polar
 * coordinates on the circle, and then to cartesian coordinates in the viewport.
 *
 * @param {?} currentValue The current percentage value of the progress circle, the percentage of the
 *    circle to fill.
 * @param {?} rotation The starting point of the circle with 0 being the 0 degree point.
 * @return {?} A string for an SVG path representing a circle filled from the starting point to the
 *    percentage value provided.
 */
function getSvgArc(currentValue, rotation) {
    /** @type {?} */
    var startPoint = rotation || 0;
    /** @type {?} */
    var radius = 50;
    /** @type {?} */
    var pathRadius = 40;
    /** @type {?} */
    var startAngle = startPoint * MAX_ANGLE;
    /** @type {?} */
    var endAngle = currentValue * MAX_ANGLE;
    /** @type {?} */
    var start = polarToCartesian(radius, pathRadius, startAngle);
    /** @type {?} */
    var end = polarToCartesian(radius, pathRadius, endAngle + startAngle);
    /** @type {?} */
    var arcSweep = endAngle < 0 ? 0 : 1;
    /** @type {?} */
    var largeArcFlag;
    if (endAngle < 0) {
        largeArcFlag = endAngle >= -180 ? 0 : 1;
    }
    else {
        largeArcFlag = endAngle <= 180 ? 0 : 1;
    }
    return "M" + start + "A" + pathRadius + "," + pathRadius + " 0 " + largeArcFlag + "," + arcSweep + " " + end;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3Mtc3Bpbm5lci5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIm5nLXVpa2l0LXByby1zdGFuZGFyZC9saWIvcHJvL3Byb2dyZXNzYmFycy9wcm9ncmVzcy1zcGlubmVyLW1vZHVsZS9wcm9ncmVzcy1zcGlubmVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsV0FBVyxFQUNYLHVCQUF1QixFQUV2QixLQUFLLEVBQ0wsVUFBVSxFQUNWLE1BQU0sRUFDTixTQUFTLEVBQ1QsU0FBUyxHQUNWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3BELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3BEO0FBQ0c7QUFBK0I7QUFDdEI7O0FBQUksSUFBVixpQkFBaUIsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLEdBQUc7QUFDdkM7QUFBSTtBQUNKO0FBQWE7QUFBSSxJQUFYLHNCQUFzQixHQUFHLEdBQUc7QUFDbEM7QUFBSTtBQUNKO0FBQWE7QUFBSSxJQUFYLG9CQUFvQixHQUFHLEdBQUc7QUFDaEM7QUFBSTtBQUNKO0FBQWE7QUFBSSxJQUFYLGtCQUFrQixHQUFHLENBQUM7QUFDNUI7QUFBSTtBQUNKO0FBQWE7QUFBSSxJQUFYLGdCQUFnQixHQUFHLEVBQUU7QUFDM0I7QUFDQTtBQUFpQixJQUFYLFNBQVMsR0FBRyxNQUFNLEdBQUcsR0FBRztBQUM5QjtBQUNHO0FBRVE7QUFDQTtBQVVYO0FBR08sSUFIUDtBQUN1QyxJQUl2QyxDQUFDLEFBRlE7QUFBQztZQUhULFNBQVMsU0FBQyxzQkFDVCxRQUFRLEVBQUUsOURBR00sdUJBQWYsV0FBVyxTQUFDLDRCQUE0QjtBQUFNO2VBSEEsbUJBQ2hEOzs7Ozs7Ozs7Ozs7b0JBRXNEO0FBQ3ZELElBQUEsNkNBQUM7QUFFRCxDQUZDLEFBTEQs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QUFBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFlQSxBQUFBLEFBS0EsQUFBQSxBQUxBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUxBLEFBS0EsQUFGQSxBQUFBLEFBQ0EsQUFBQSxBQU1BLEFBb0dBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUhBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQWhHQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBUUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBdUZBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQWpGQSxBQUFBLEFBQUEsQUFMQSxBQUlBLEFBQ0EsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFHQSxBQUFBLEFBQUEsQUFEQSxBQUFBLEFBQ0EsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFMQSxBQU9BLEFBRUEsQUFDQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBR0EsQUFDQSxBQUFBLEFBRkEsQUFBQSxBQUNBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBSEEsQUFNQSxBQUVBLEFBQUEsQUFIQSxBQUFBLEFBQ0EsQUFHQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFDQSxBQUFBLEFBUEEsQUFlQSxBQUVBLEFBQUEsQUFSQSxBQUtBLEFBQ0EsQUFHQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFDQSxBQUFBLEFBWEEsQUFzQkEsQUFTQSxBQUNBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBTEEsQUErQkEsQUE1QkEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFFQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQ0EsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQ0EsQUFBQSxBQUVBLEFBRUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQXNCQSxBQXJCQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFDQSxBQUNBLEFBQUEsQUFFQSxBQUVBLEFBQ0EsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBRUEsQUFHQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQ0EsQUFBQSxBQUVBLEFBR0EsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFFQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQ0EsQUFDQSxBQUFBLEFBMU5BLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBL0NBLEFBQUEsQUFEQSxBQUFBLEFBRUEsQUFBQSxBQWtKQSxBQUFBLEFBQUEsQUFBQSxBQXBGQSxBQUFBLEFBQUEsQUFBQSxBQWdDQSxBQUFBLEFBU0EsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBcUJBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQXVJQSxBQUFBLEFBQUEsQUEzTkEsQUEyTkEsQUF0TkEsQUFBQSxBQUVBLEFBQUEsQUFHQSxBQUFBLEFBR0EsQUFBQSxBQUVBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUVBLEFBQUEsQUFDQSxBQUFBLEFBaUZBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQTRIQSxBQUtBLEFBQUEsQUFHQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUVBLEFBREEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBRUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQWpCQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFFQSxBQW5SQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFtUkEsQUFBQSxBQUFBLEFBQUEsQUFZQSxBQUFBLEFBQUEsQUFsQkEsQUFLQSxBQUFBLEFBYUEsQUFiQSxBQUFBLEFBQ0EsQUFBQSxBQW1CQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUtBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBRUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUtBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBS0EsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFZQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFFQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUVBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBRUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgSG9zdEJpbmRpbmcsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBPbkRlc3Ryb3ksXG4gIElucHV0LFxuICBFbGVtZW50UmVmLFxuICBOZ1pvbmUsXG4gIFJlbmRlcmVyMixcbiAgRGlyZWN0aXZlLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IFBMQVRGT1JNX0lELCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqIEEgc2luZ2xlIGRlZ3JlZSBpbiByYWRpYW5zLiAqL1xuY29uc3QgREVHUkVFX0lOX1JBRElBTlMgPSBNYXRoLlBJIC8gMTgwO1xuLyoqIER1cmF0aW9uIG9mIHRoZSBpbmRldGVybWluYXRlIGFuaW1hdGlvbi4gKi9cbmNvbnN0IERVUkFUSU9OX0lOREVURVJNSU5BVEUgPSA2Njc7XG4vKiogRHVyYXRpb24gb2YgdGhlIGluZGV0ZXJtaW5hdGUgYW5pbWF0aW9uLiAqL1xuY29uc3QgRFVSQVRJT05fREVURVJNSU5BVEUgPSAyMjU7XG4vKiogU3RhcnQgYW5pbWF0aW9uIHZhbHVlIG9mIHRoZSBpbmRldGVybWluYXRlIGFuaW1hdGlvbiAqL1xuY29uc3Qgc3RhcnRJbmRldGVybWluYXRlID0gMztcbi8qKiBFbmQgYW5pbWF0aW9uIHZhbHVlIG9mIHRoZSBpbmRldGVybWluYXRlIGFuaW1hdGlvbiAqL1xuY29uc3QgZW5kSW5kZXRlcm1pbmF0ZSA9IDgwO1xuLyogTWF4aW11bSBhbmdsZSBmb3IgdGhlIGFyYy4gVGhlIGFuZ2xlIGNhbid0IGJlIGV4YWN0bHkgMzYwLCBiZWNhdXNlIHRoZSBhcmMgYmVjb21lcyBoaWRkZW4uICovXG5jb25zdCBNQVhfQU5HTEUgPSAzNTkuOTkgLyAxMDA7XG5cbmV4cG9ydCB0eXBlIFByb2dyZXNzU3Bpbm5lck1vZGUgPSAnZGV0ZXJtaW5hdGUnIHwgJ2luZGV0ZXJtaW5hdGUnO1xuXG50eXBlIEVhc2luZ0ZuID0gKFxuICBjdXJyZW50VGltZTogbnVtYmVyLFxuICBzdGFydFZhbHVlOiBudW1iZXIsXG4gIGNoYW5nZUluVmFsdWU6IG51bWJlcixcbiAgZHVyYXRpb246IG51bWJlclxuKSA9PiBudW1iZXI7XG5cbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1ttZGJTcGlubmVyc10sIG1hdC1wcm9ncmVzcy1zcGlubmVyJyxcbn0pXG5leHBvcnQgY2xhc3MgTWRQcm9ncmVzc1NwaW5uZXJDc3NNYXRTdHlsZXJEaXJlY3RpdmUge1xuICBASG9zdEJpbmRpbmcoJ2NsYXNzLm1hdC1wcm9ncmVzcy1zcGlubmVyJykgdHJ1ZTogYW55O1xufVxuXG4vKipcbiAqIDxtZC1wcm9ncmVzcy1zcGlubmVyPiBjb21wb25lbnQuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ21kYi1TcGlubmVycywgbWF0LXByb2dyZXNzLXNwaW5uZXInLFxuICB0ZW1wbGF0ZVVybDogJ3Byb2dyZXNzLXNwaW5uZXIuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgTWRQcm9ncmVzc1NwaW5uZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAvKiogVGhlIGlkIG9mIHRoZSBsYXN0IHJlcXVlc3RlZCBhbmltYXRpb24uICovXG4gIHByaXZhdGUgX2xhc3RBbmltYXRpb25JZCA9IDA7XG5cbiAgLyoqIFRoZSBpZCBvZiB0aGUgaW5kZXRlcm1pbmF0ZSBpbnRlcnZhbC4gKi9cbiAgcHJpdmF0ZSBfaW50ZXJkZXRlcm1pbmF0ZUludGVydmFsOiBhbnk7XG5cbiAgLyoqIFRoZSBTVkcgPHBhdGg+IG5vZGUgdGhhdCBpcyB1c2VkIHRvIGRyYXcgdGhlIGNpcmNsZS4gKi9cbiAgcHJpdmF0ZSBfcGF0aDogU1ZHUGF0aEVsZW1lbnQ7XG5cbiAgcHJpdmF0ZSBfbW9kZTogUHJvZ3Jlc3NTcGlubmVyTW9kZSA9ICdkZXRlcm1pbmF0ZSc7XG4gIHByaXZhdGUgX3ZhbHVlOiBudW1iZXI7XG4gIHByaXZhdGUgX2NvbG9yID0gJ3ByaW1hcnknO1xuXG4gIGlzQnJvd3NlcjogYW55ID0gZmFsc2U7XG4gIEBJbmplY3QoUExBVEZPUk1fSUQpIHBsYXRmb3JtSWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFZhbHVlcyBmb3IgYXJpYSBtYXggYW5kIG1pbiBhcmUgb25seSBkZWZpbmVkIGFzIG51bWJlcnMgd2hlbiBpbiBhIGRldGVybWluYXRlIG1vZGUuICBXZSBkbyB0aGlzXG4gICAqIGJlY2F1c2Ugdm9pY2VvdmVyIGRvZXMgbm90IHJlcG9ydCB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yIGFzIGluZGV0ZXJtaW5hdGUgaWYgdGhlIGFyaWEgbWluXG4gICAqIGFuZC9vciBtYXggdmFsdWUgYXJlIG51bWJlciB2YWx1ZXMuXG4gICAqL1xuICBnZXQgX2FyaWFWYWx1ZU1pbigpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlID09PSAnZGV0ZXJtaW5hdGUnID8gMCA6IG51bGw7XG4gIH1cblxuICBnZXQgX2FyaWFWYWx1ZU1heCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlID09PSAnZGV0ZXJtaW5hdGUnID8gMTAwIDogbnVsbDtcbiAgfVxuXG4gIC8qKiBAZG9jcy1wcml2YXRlICovXG4gIGdldCBpbnRlcmRldGVybWluYXRlSW50ZXJ2YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbDtcbiAgfVxuICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICBzZXQgaW50ZXJkZXRlcm1pbmF0ZUludGVydmFsKGludGVydmFsKSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcmRldGVybWluYXRlSW50ZXJ2YWwpO1xuICAgIHRoaXMuX2ludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbCA9IGludGVydmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGFueSBhbmltYXRpb25zIHRoYXQgd2VyZSBydW5uaW5nLlxuICAgKi9cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fY2xlYW51cEluZGV0ZXJtaW5hdGVBbmltYXRpb24oKTtcbiAgfVxuXG4gIC8qKiBUaGUgY29sb3Igb2YgdGhlIHByb2dyZXNzLXNwaW5uZXIuIENhbiBiZSBwcmltYXJ5LCBhY2NlbnQsIG9yIHdhcm4uICovXG4gIEBJbnB1dCgpXG4gIGdldCBjb2xvcigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbiAgfVxuICBzZXQgY29sb3IodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgfVxuXG4gIC8qKiBWYWx1ZSBvZiB0aGUgcHJvZ3Jlc3MgY2lyY2xlLiBJdCBpcyBib3VuZCB0byB0aGUgaG9zdCBhcyB0aGUgYXR0cmlidXRlIGFyaWEtdmFsdWVub3cuICovXG4gIEBJbnB1dCgpXG4gIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLXZhbHVlbm93JylcbiAgZ2V0IHZhbHVlKCk6IGFueSB7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ2RldGVybWluYXRlJykge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgc2V0IHZhbHVlKHY6IG51bWJlciB8IGFueSkge1xuICAgIGlmICh2ICE9IG51bGwgJiYgdGhpcy5tb2RlID09PSAnZGV0ZXJtaW5hdGUnKSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IGNsYW1wKHYpO1xuICAgICAgdGhpcy5fYW5pbWF0ZUNpcmNsZSh0aGlzLnZhbHVlIHx8IDAsIG5ld1ZhbHVlKTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vZGUgb2YgdGhlIHByb2dyZXNzIGNpcmNsZVxuICAgKlxuICAgKiBJbnB1dCBtdXN0IGJlIG9uZSBvZiB0aGUgdmFsdWVzIGZyb20gUHJvZ3Jlc3NNb2RlLCBkZWZhdWx0cyB0byAnZGV0ZXJtaW5hdGUnLlxuICAgKiBtb2RlIGlzIGJvdW5kIHRvIHRoZSBob3N0IGFzIHRoZSBhdHRyaWJ1dGUgaG9zdC5cbiAgICovXG4gIEBIb3N0QmluZGluZygnYXR0ci5tb2RlJylcbiAgQElucHV0KClcbiAgZ2V0IG1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gIH1cbiAgc2V0IG1vZGUobW9kZTogUHJvZ3Jlc3NTcGlubmVyTW9kZSkge1xuICAgIGlmIChtb2RlICE9PSB0aGlzLl9tb2RlKSB7XG4gICAgICBpZiAobW9kZSA9PT0gJ2luZGV0ZXJtaW5hdGUnKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0SW5kZXRlcm1pbmF0ZUFuaW1hdGlvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cEluZGV0ZXJtaW5hdGVBbmltYXRpb24oKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZUNpcmNsZSgwLCB0aGlzLl92YWx1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tb2RlID0gbW9kZTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSxcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcGxhdGZvcm1JZD86IHN0cmluZyB8IGFueVxuICApIHtcbiAgICB0aGlzLmlzQnJvd3NlciA9IGlzUGxhdGZvcm1Ccm93c2VyKHBsYXRmb3JtSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuaW1hdGVzIHRoZSBjaXJjbGUgZnJvbSBvbmUgcGVyY2VudGFnZSB2YWx1ZSB0byBhbm90aGVyLlxuICAgKlxuICAgKiBAcGFyYW0gYW5pbWF0ZUZyb20gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNpcmNsZSBmaWxsZWQgc3RhcnRpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIGFuaW1hdGVUbyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2lyY2xlIGZpbGxlZCBlbmRpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIGVhc2UgVGhlIGVhc2luZyBmdW5jdGlvbiB0byBtYW5hZ2UgdGhlIHBhY2Ugb2YgY2hhbmdlIGluIHRoZSBhbmltYXRpb24uXG4gICAqIEBwYXJhbSBkdXJhdGlvbiBUaGUgbGVuZ3RoIG9mIHRpbWUgdG8gc2hvdyB0aGUgYW5pbWF0aW9uLCBpbiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSByb3RhdGlvbiBUaGUgc3RhcnRpbmcgYW5nbGUgb2YgdGhlIGNpcmNsZSBmaWxsLCB3aXRoIDDCsCByZXByZXNlbnRlZCBhdCB0aGUgdG9wIGNlbnRlclxuICAgKiAgICBvZiB0aGUgY2lyY2xlLlxuICAgKi9cbiAgcHJpdmF0ZSBfYW5pbWF0ZUNpcmNsZShcbiAgICBhbmltYXRlRnJvbTogbnVtYmVyLFxuICAgIGFuaW1hdGVUbzogbnVtYmVyLFxuICAgIGVhc2U6IEVhc2luZ0ZuID0gbGluZWFyRWFzZSxcbiAgICBkdXJhdGlvbiA9IERVUkFUSU9OX0RFVEVSTUlOQVRFLFxuICAgIHJvdGF0aW9uID0gMFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBpZCA9ICsrdGhpcy5fbGFzdEFuaW1hdGlvbklkO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgY2hhbmdlSW5WYWx1ZSA9IGFuaW1hdGVUbyAtIGFuaW1hdGVGcm9tO1xuXG4gICAgLy8gTm8gbmVlZCB0byBhbmltYXRlIGl0IGlmIHRoZSB2YWx1ZXMgYXJlIHRoZSBzYW1lXG4gICAgaWYgKGFuaW1hdGVUbyA9PT0gYW5pbWF0ZUZyb20pIHtcbiAgICAgIHRoaXMuX3JlbmRlckFyYyhhbmltYXRlVG8sIHJvdGF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYW5pbWF0aW9uID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBlbGFwc2VkVGltZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKERhdGUubm93KCkgLSBzdGFydFRpbWUsIGR1cmF0aW9uKSk7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyQXJjKGVhc2UoZWxhcHNlZFRpbWUsIGFuaW1hdGVGcm9tLCBjaGFuZ2VJblZhbHVlLCBkdXJhdGlvbiksIHJvdGF0aW9uKTtcblxuICAgICAgICAvLyBQcmV2ZW50IG92ZXJsYXBwaW5nIGFuaW1hdGlvbnMgYnkgY2hlY2tpbmcgaWYgYSBuZXcgYW5pbWF0aW9uIGhhcyBiZWVuIGNhbGxlZCBmb3IgYW5kXG4gICAgICAgIC8vIGlmIHRoZSBhbmltYXRpb24gaGFzIGxhc3RlZCBsb25nZXIgdGhhbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uLlxuICAgICAgICBpZiAoaWQgPT09IHRoaXMuX2xhc3RBbmltYXRpb25JZCAmJiBlbGFwc2VkVGltZSA8IGR1cmF0aW9uKSB7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIFJ1biB0aGUgYW5pbWF0aW9uIG91dHNpZGUgb2YgQW5ndWxhcidzIHpvbmUsIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgICAvLyBoaXR0aW5nIFpvbmVKUyBhbmQgY2hhbmdlIGRldGVjdGlvbiBvbiBlYWNoIGZyYW1lLlxuICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGFuaW1hdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgaW5kZXRlcm1pbmF0ZSBhbmltYXRpb24gaW50ZXJ2YWwsIGlmIGl0IGlzIG5vdCBhbHJlYWR5IHJ1bm5pbmcuXG4gICAqL1xuICBwcml2YXRlIF9zdGFydEluZGV0ZXJtaW5hdGVBbmltYXRpb24oKTogdm9pZCB7XG4gICAgbGV0IHJvdGF0aW9uU3RhcnRQb2ludCA9IDA7XG4gICAgbGV0IHN0YXJ0ID0gc3RhcnRJbmRldGVybWluYXRlO1xuICAgIGxldCBlbmQgPSBlbmRJbmRldGVybWluYXRlO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gRFVSQVRJT05fSU5ERVRFUk1JTkFURTtcbiAgICBjb25zdCBhbmltYXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fYW5pbWF0ZUNpcmNsZShzdGFydCwgZW5kLCBtYXRlcmlhbEVhc2UsIGR1cmF0aW9uLCByb3RhdGlvblN0YXJ0UG9pbnQpO1xuICAgICAgLy8gUHJldmVudCByb3RhdGlvbiBmcm9tIHJlYWNoaW5nIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLlxuICAgICAgcm90YXRpb25TdGFydFBvaW50ID0gKHJvdGF0aW9uU3RhcnRQb2ludCArIGVuZCkgJSAxMDA7XG4gICAgICBjb25zdCB0ZW1wID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IC1lbmQ7XG4gICAgICBlbmQgPSAtdGVtcDtcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuaXNCcm93c2VyKSB7XG4gICAgICBpZiAoIXRoaXMuaW50ZXJkZXRlcm1pbmF0ZUludGVydmFsKSB7XG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5pbnRlcmRldGVybWluYXRlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChhbmltYXRlLCBkdXJhdGlvbiArIDUwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgYW5pbWF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBpbnRlcnZhbCwgZW5kaW5nIHRoZSBhbmltYXRpb24uXG4gICAqL1xuICBwcml2YXRlIF9jbGVhbnVwSW5kZXRlcm1pbmF0ZUFuaW1hdGlvbigpOiB2b2lkIHtcbiAgICB0aGlzLmludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYXJjIG9udG8gdGhlIFNWRyBlbGVtZW50LiBQcm94aWVzIGBnZXRBcmNgIHdoaWxlIHNldHRpbmcgdGhlIHByb3BlclxuICAgKiBET00gYXR0cmlidXRlIG9uIHRoZSBgPHBhdGg+YC5cbiAgICovXG4gIHByaXZhdGUgX3JlbmRlckFyYyhjdXJyZW50VmFsdWU6IG51bWJlciwgcm90YXRpb24gPSAwKTogdm9pZCB7XG4gICAgLy8gQ2FjaGVzIHRoZSBwYXRoIHJlZmVyZW5jZSBzbyBpdCBkb2Vzbid0IGhhdmUgdG8gYmUgbG9va2VkIHVwIGV2ZXJ5IHRpbWUuXG4gICAgY29uc3QgcGF0aCA9ICh0aGlzLl9wYXRoID0gdGhpcy5fcGF0aCB8fCB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcigncGF0aCcpKTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBwYXRoIHdhcyBmb3VuZC4gVGhpcyBtYXkgbm90IGJlIHRoZSBjYXNlIGlmIHRoZVxuICAgIC8vIGFuaW1hdGlvbiBmdW5jdGlvbiBmaXJlcyB0b28gZWFybHkuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdkJywgZ2V0U3ZnQXJjKGN1cnJlbnRWYWx1ZSwgcm90YXRpb24pKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29sb3Igb2YgdGhlIHByb2dyZXNzLXNwaW5uZXIgYnkgYWRkaW5nIHRoZSBuZXcgcGFsZXR0ZSBjbGFzcyB0byB0aGUgZWxlbWVudFxuICAgKiBhbmQgcmVtb3ZpbmcgdGhlIG9sZCBvbmUuXG4gICAqL1xuICBwcml2YXRlIF91cGRhdGVDb2xvcihuZXdDb2xvcjogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKHRoaXMuX2NvbG9yLCBmYWxzZSk7XG4gICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKG5ld0NvbG9yLCB0cnVlKTtcbiAgICB0aGlzLl9jb2xvciA9IG5ld0NvbG9yO1xuICB9XG5cbiAgLyoqIFNldHMgdGhlIGdpdmVuIHBhbGV0dGUgY2xhc3Mgb24gdGhlIGNvbXBvbmVudCBlbGVtZW50LiAqL1xuICBwcml2YXRlIF9zZXRFbGVtZW50Q29sb3IoY29sb3I6IHN0cmluZywgaXNBZGQ6IGJvb2xlYW4pIHtcbiAgICBpZiAoY29sb3IgIT0gbnVsbCAmJiBjb2xvciAhPT0gJycpIHtcbiAgICAgIGlmIChpc0FkZCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIGBtYXQtJHtjb2xvcn1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiA8bWQtc3Bpbm5lcj4gY29tcG9uZW50LlxuICpcbiAqIFRoaXMgaXMgYSBjb21wb25lbnQgZGVmaW5pdGlvbiB0byBiZSB1c2VkIGFzIGEgY29udmVuaWVuY2UgcmVmZXJlbmNlIHRvIGNyZWF0ZSBhblxuICogaW5kZXRlcm1pbmF0ZSA8bWQtcHJvZ3Jlc3Mtc3Bpbm5lcj4gaW5zdGFuY2UuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ21kYi1zcGlubmVycywgbWF0LXNwaW5uZXIsIG1kYi1wcm9ncmVzcy1zcGlubmVyJyxcbiAgdGVtcGxhdGVVcmw6ICdwcm9ncmVzcy1zcGlubmVyLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJ3Byb2dyZXNzLXNwaW5uZXIuY29tcG9uZW50LnNjc3MnXSxcbn0pXG5leHBvcnQgY2xhc3MgTWRTcGlubmVyQ29tcG9uZW50IGV4dGVuZHMgTWRQcm9ncmVzc1NwaW5uZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBASG9zdEJpbmRpbmcoJ2NsYXNzLm1hdC1zcGlubmVyJykgdHJ1ZTogYW55O1xuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIG5nWm9uZTogTmdab25lLCByZW5kZXJlcjogUmVuZGVyZXIyKSB7XG4gICAgc3VwZXIobmdab25lLCBlbGVtZW50UmVmLCByZW5kZXJlcik7XG4gICAgdGhpcy5tb2RlID0gJ2luZGV0ZXJtaW5hdGUnO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgLy8gVGhlIGBuZ09uRGVzdHJveWAgZnJvbSBgTWRQcm9ncmVzc1NwaW5uZXJgIHNob3VsZCBiZSBjYWxsZWQgZXhwbGljaXRseSwgYmVjYXVzZVxuICAgIC8vIGluIGNlcnRhaW4gY2FzZXMgQW5ndWxhciB3b24ndCBjYWxsIGl0IChlLmcuIHdoZW4gdXNpbmcgQW9UIGFuZCBpbiB1bml0IHRlc3RzKS5cbiAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICB9XG59XG5cbi8qKlxuICogTW9kdWxlIGZ1bmN0aW9ucy5cbiAqL1xuXG4vKiogQ2xhbXBzIGEgdmFsdWUgdG8gYmUgYmV0d2VlbiAwIGFuZCAxMDAuICovXG5mdW5jdGlvbiBjbGFtcCh2OiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgdikpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIFBvbGFyIGNvb3JkaW5hdGVzIHRvIENhcnRlc2lhbi5cbiAqL1xuZnVuY3Rpb24gcG9sYXJUb0NhcnRlc2lhbihyYWRpdXM6IG51bWJlciwgcGF0aFJhZGl1czogbnVtYmVyLCBhbmdsZUluRGVncmVlczogbnVtYmVyKSB7XG4gIGNvbnN0IGFuZ2xlSW5SYWRpYW5zID0gKGFuZ2xlSW5EZWdyZWVzIC0gOTApICogREVHUkVFX0lOX1JBRElBTlM7XG5cbiAgcmV0dXJuIChcbiAgICByYWRpdXMgK1xuICAgIHBhdGhSYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUluUmFkaWFucykgK1xuICAgICcsJyArXG4gICAgKHJhZGl1cyArIHBhdGhSYWRpdXMgKiBNYXRoLnNpbihhbmdsZUluUmFkaWFucykpXG4gICk7XG59XG5cbi8qKlxuICogRWFzaW5nIGZ1bmN0aW9uIGZvciBsaW5lYXIgYW5pbWF0aW9uLlxuICovXG5mdW5jdGlvbiBsaW5lYXJFYXNlKFxuICBjdXJyZW50VGltZTogbnVtYmVyLFxuICBzdGFydFZhbHVlOiBudW1iZXIsXG4gIGNoYW5nZUluVmFsdWU6IG51bWJlcixcbiAgZHVyYXRpb246IG51bWJlclxuKSB7XG4gIHJldHVybiAoY2hhbmdlSW5WYWx1ZSAqIGN1cnJlbnRUaW1lKSAvIGR1cmF0aW9uICsgc3RhcnRWYWx1ZTtcbn1cblxuLyoqXG4gKiBFYXNpbmcgZnVuY3Rpb24gdG8gbWF0Y2ggbWF0ZXJpYWwgZGVzaWduIGluZGV0ZXJtaW5hdGUgYW5pbWF0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRlcmlhbEVhc2UoXG4gIGN1cnJlbnRUaW1lOiBudW1iZXIsXG4gIHN0YXJ0VmFsdWU6IG51bWJlcixcbiAgY2hhbmdlSW5WYWx1ZTogbnVtYmVyLFxuICBkdXJhdGlvbjogbnVtYmVyXG4pIHtcbiAgY29uc3QgdGltZSA9IGN1cnJlbnRUaW1lIC8gZHVyYXRpb247XG4gIGNvbnN0IHRpbWVDdWJlZCA9IE1hdGgucG93KHRpbWUsIDMpO1xuICBjb25zdCB0aW1lUXVhZCA9IE1hdGgucG93KHRpbWUsIDQpO1xuICBjb25zdCB0aW1lUXVpbnQgPSBNYXRoLnBvdyh0aW1lLCA1KTtcbiAgcmV0dXJuIHN0YXJ0VmFsdWUgKyBjaGFuZ2VJblZhbHVlICogKDYgKiB0aW1lUXVpbnQgKyAtMTUgKiB0aW1lUXVhZCArIDEwICogdGltZUN1YmVkKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBwYXRoIHZhbHVlIHRvIGRlZmluZSB0aGUgYXJjLiAgQ29udmVydGluZyBwZXJjZW50YWdlIHZhbHVlcyB0byB0byBwb2xhclxuICogY29vcmRpbmF0ZXMgb24gdGhlIGNpcmNsZSwgYW5kIHRoZW4gdG8gY2FydGVzaWFuIGNvb3JkaW5hdGVzIGluIHRoZSB2aWV3cG9ydC5cbiAqXG4gKiBAcGFyYW0gY3VycmVudFZhbHVlIFRoZSBjdXJyZW50IHBlcmNlbnRhZ2UgdmFsdWUgb2YgdGhlIHByb2dyZXNzIGNpcmNsZSwgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlXG4gKiAgICBjaXJjbGUgdG8gZmlsbC5cbiAqIEBwYXJhbSByb3RhdGlvbiBUaGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGNpcmNsZSB3aXRoIDAgYmVpbmcgdGhlIDAgZGVncmVlIHBvaW50LlxuICogQHJldHVybiBBIHN0cmluZyBmb3IgYW4gU1ZHIHBhdGggcmVwcmVzZW50aW5nIGEgY2lyY2xlIGZpbGxlZCBmcm9tIHRoZSBzdGFydGluZyBwb2ludCB0byB0aGVcbiAqICAgIHBlcmNlbnRhZ2UgdmFsdWUgcHJvdmlkZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFN2Z0FyYyhjdXJyZW50VmFsdWU6IG51bWJlciwgcm90YXRpb246IG51bWJlcikge1xuICBjb25zdCBzdGFydFBvaW50ID0gcm90YXRpb24gfHwgMDtcbiAgY29uc3QgcmFkaXVzID0gNTA7XG4gIGNvbnN0IHBhdGhSYWRpdXMgPSA0MDtcblxuICBjb25zdCBzdGFydEFuZ2xlID0gc3RhcnRQb2ludCAqIE1BWF9BTkdMRTtcbiAgY29uc3QgZW5kQW5nbGUgPSBjdXJyZW50VmFsdWUgKiBNQVhfQU5HTEU7XG4gIGNvbnN0IHN0YXJ0ID0gcG9sYXJUb0NhcnRlc2lhbihyYWRpdXMsIHBhdGhSYWRpdXMsIHN0YXJ0QW5nbGUpO1xuICBjb25zdCBlbmQgPSBwb2xhclRvQ2FydGVzaWFuKHJhZGl1cywgcGF0aFJhZGl1cywgZW5kQW5nbGUgKyBzdGFydEFuZ2xlKTtcbiAgY29uc3QgYXJjU3dlZXAgPSBlbmRBbmdsZSA8IDAgPyAwIDogMTtcbiAgbGV0IGxhcmdlQXJjRmxhZzogbnVtYmVyO1xuXG4gIGlmIChlbmRBbmdsZSA8IDApIHtcbiAgICBsYXJnZUFyY0ZsYWcgPSBlbmRBbmdsZSA+PSAtMTgwID8gMCA6IDE7XG4gIH0gZWxzZSB7XG4gICAgbGFyZ2VBcmNGbGFnID0gZW5kQW5nbGUgPD0gMTgwID8gMCA6IDE7XG4gIH1cblxuICByZXR1cm4gYE0ke3N0YXJ0fUEke3BhdGhSYWRpdXN9LCR7cGF0aFJhZGl1c30gMCAke2xhcmdlQXJjRmxhZ30sJHthcmNTd2VlcH0gJHtlbmR9YDtcbn1cbiJdfQ==